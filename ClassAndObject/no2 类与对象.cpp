#include <iostream>
#include "类与对象.h"
using namespace std;

//在源文件中实现头文件中类方法的方法体，需要在方法名前面加上类名和域运算符，如：Rect::
Rect::Rect() {}
Rect::Rect(int nLength, int nWidth)
{
	m_nLength = nLength;
	m_nWidth = nWidth;
}
Rect::Rect(int nLength)//构造了一个正方形，因为长宽相等
{
	m_nLength = nLength;
	m_nWidth = nLength;
}
void Rect::setLength(int nLength=20)//长度的默认值是20
{
	m_nLength = nLength;
}
void Rect::setWidth(int nWidth)
{
	m_nWidth = nWidth;
}
inline int Rect::getArea()
{
	return m_nLength * m_nWidth;
}
int Rect::getPerimeter()
{
	return (m_nLength + m_nWidth) * 2;
}

//类的基本用法
void test01()
{
	//这里使用类和对象完成程序的逻辑
	Rect r1, r2;
	//通过对象名.函数名来调用类中的函数
	r1.setLength(6);
	r1.setWidth(4);
	r2.setLength(10);
	r2.setWidth(5);
	cout << "矩形r1的面积：" << r1.getArea() << endl;
	cout << "矩形r1的周长：" << r1.getPerimeter() << endl;
	cout << "矩形r2的面积：" << r2.getArea() << endl;
	cout << "矩形r2的周长：" << r2.getPerimeter() << endl;

	//使用new在堆内存动态创建一个对象
	Rect* pR3 = new Rect;
	pR3->setLength(5);
	pR3->setWidth(3);
	cout << "矩形r3的面积：" << pR3->getArea() << endl;
	cout << "矩形r3的周长：" << pR3->getPerimeter() << endl;
	//别忘了释放堆内存
	delete pR3;
	pR3 = NULL;//再次置空，防止指针悬空，因为这个地址指向的内存已经被系统回收使用，不再归这个指针管理了。

	//查看对象占用的内存空间
	cout << "Rect类的大小：" << sizeof(Rect) << endl;
	cout << "r1对象的大小：" << sizeof(r1) << endl;
	cout << "r2对象的大小：" << sizeof(r2) << endl;
	cout << "r1对象的地址：" << &r1 << endl;
	cout << "r2对象的地址：" << &r2 << endl;
}

//构造函数的使用
void test02()
{
	//定义一个Rect类对象，通过构造函数完成初始化，由编译器自动调用
	Rect r(10, 6);
	cout << "矩形的面积：" << r.getArea() << endl;
	cout << "矩形的周长：" << r.getPerimeter() << endl;
	//接下来调用一个参数的构造函数，构造一个正方形
	Rect r1(100);
	cout << "矩形的面积：" << r1.getArea() << endl;
	cout << "矩形的周长：" << r1.getPerimeter() << endl;
}

//演示初始化列表
class Test1
{
	const int m_nHigh;//常量，必须使用初始化列表来初始化
	int& m_nRef;//引用，必须使用初始化列表
	int m_nLength;//普通属性，哪种都可以
	int m_nWidth;
public:
	Test1(int high, int ref, int len, int wid) :m_nHigh(high), m_nRef(ref), m_nLength(len)
	{
		m_nWidth = wid;
	}
	void show() {
		cout << "长：" << m_nLength << "，宽：" << m_nWidth << "，高：" << m_nHigh << endl;
	}
};
void test03()
{
	Test1 t(10,0,50,30);
	t.show();
}

//演示析构函数的作用
class Test2
{
	int m_nLength;
	int m_nWidth;
	char* m_pName = NULL;//姓名属性，是指针
public:
	Test2(int len, int wid, const char* pName)
	{
		m_nLength = len;
		m_nWidth = wid;
		//接下来动态申请堆内存，保存姓名
		m_pName = new char[strlen(pName) + 1];//申请的堆内存空间长度为pName长度+1，+1是给结束符准备的
		strcpy_s(m_pName, strlen(pName) + 1, pName);//完成拷贝
		cout << "执行了构造函数，构造了" << m_pName << endl;
	}
	//~Test2()
	//{
	//	if (m_pName!=NULL)//判断以下，如果不为空，说明申请了堆内存，才需要释放
	//	{
	//		cout << "执行了析构函数，释放了对象申请的堆内存，析构了" << m_pName << endl;
	//		delete[]m_pName;//释放了内存
	//		m_pName = NULL;//再次置空
	//	}
	//}
	//提供一个修改姓名的方法
	void setName(const char* cName){strcpy_s(m_pName, strlen(cName) + 1, cName);}
	//提供一个展示姓名的方法
	void show() {
		if (m_pName!=NULL)
		{
			cout << "姓名：" << m_pName << endl;
		}
	}
};
//演示析构函数的调用
void test04()
{
	//观察构造和析构的顺序是相反的，同时析构函数帮我们释放了申请的堆内存
	Test2 t1(10, 5, "测试1");
	Test2 t2(20, 10, "测试2");
}

//演示拷贝构造函数的用法
class A
{
	int m_a;
public:
	A(){}//无参构造
	A(int ma) { m_a = ma; }//有参构造
	//下面是拷贝构造
	A(const A& a) { m_a = a.m_a; cout << "调用了拷贝构造函数" << endl; }//通过a对象的属性来给新对象的属性赋值，编译器也会提供默认的拷贝构造函数，所以即使把这一行注释掉，也能使用拷贝构造
	int getMA() { return m_a; }
};
void fun1(const A& a) {};//参数是引用
void fun2(A a) {};//参数不是引用类型，是普通的对象类型
void test05()
{
	A a1(10);//构造函数
	//A a2(a1);//a2是通过a1拷贝而来
	//cout << "a1:" << a1.getMA() << endl;
	//cout << "a2:" << a2.getMA() << endl;
	cout << "接下来查看对象类型的引用传参和普通传参的区别" << endl;
	cout << "首先调用fun1,它是引用传参" << endl;
	fun1(a1);
	cout << "再调用fun2,它不是引用传参，是普通传参" << endl;
	fun2(a1);

}

//关于深拷贝浅拷贝的问题
void test06()
{
	//我们知道Test2类的构造函数中申请了堆内存，并且把地址保存到了它的类属性m_pName中
	//如果我们使用Test2这个类的拷贝构造函数，会发生意外
	Test2 t3(6, 3, "测试3");
	//使用拷贝构造函数，这个是编译器自动生成的
	Test2 t4(t3);//这个地方调用了默认的拷贝构造函数，将t3中的指针属性赋值给了t4的指针属性，这样t3和t4的析构函数都会释放同一块内存地址，导致报错
	//现在，把析构函数注释掉，然后展示一下t3和t4的姓名
	t3.show();
	t4.show();
	//这种浅拷贝的情况下，当我们修改某个对象的姓名的时候，会同时影响另一个对象
	t3.setName("测试33");
	t3.show();
	t4.show();
}

//这里的类，重新改造拷贝构造函数，避免上面的问题
//演示析构函数的作用
class B
{
	int m_nLength;
	int m_nWidth;
	char* m_pName = NULL;//姓名属性，是指针
public:
	B(int len, int wid, const char* pName)
	{
		m_nLength = len;
		m_nWidth = wid;
		//接下来动态申请堆内存，保存姓名
		m_pName = new char[strlen(pName) + 1];//申请的堆内存空间长度为pName长度+1，+1是给结束符准备的
		strcpy_s(m_pName, strlen(pName) + 1, pName);//完成拷贝
		cout << "执行了构造函数，构造了" << m_pName << endl;
	}
	//自己实现拷贝构造，让每个对象使用自己独立的堆内存空间存储自己的姓名，这就是深拷贝，而Test2默认调用的拷贝构造函数是浅拷贝
	B(const B& b)
	{
		m_nLength = b.m_nLength;
		m_nWidth = b.m_nWidth;
		cout << "执行拷贝构造函数，实现深拷贝" << endl;
		if (b.m_pName!=NULL)
		{
			m_pName = new char[strlen(b.m_pName) + 1];//这里申请了独立的空间来保存姓名
			strcpy_s(m_pName, strlen(b.m_pName) + 1, b.m_pName);//完成拷贝
		}
	}
	~B()
	{
		if (m_pName != NULL)//判断以下，如果不为空，说明申请了堆内存，才需要释放
		{
			cout << "执行了析构函数，释放了对象申请的堆内存，析构了" << m_pName << endl;
			delete[]m_pName;//释放了内存
			m_pName = NULL;//再次置空
		}
	}
};
void test07()
{
	B b1(10, 6, "张三");
	B b2(b1);//调用自己实现的深拷贝构造函数
}

//演示赋值函数的作用
class C
{
	int m_nLength;
	int m_nWidth;
	char* m_pName = NULL;//姓名属性，是指针
public:
	C(int len, int wid, const char* pName)
	{
		m_nLength = len;
		m_nWidth = wid;
		//接下来动态申请堆内存，保存姓名
		m_pName = new char[strlen(pName) + 1];//申请的堆内存空间长度为pName长度+1，+1是给结束符准备的
		strcpy_s(m_pName, strlen(pName) + 1, pName);//完成拷贝
		cout << "执行了构造函数，构造了" << m_pName << endl;
	}
	~C()
	{
		if (m_pName != NULL)//判断以下，如果不为空，说明申请了堆内存，才需要释放
		{
			cout << "执行了析构函数，释放了对象申请的堆内存，析构了" << m_pName << endl;
			delete[]m_pName;//释放了内存
			m_pName = NULL;//再次置空
		}
	}
	//赋值函数
	C& operator=(const C& c)
	{
		if (this!=&c)//先做一下地址检查，确保当前被赋值的对象和赋值对象不是同一个对象，也就是说不能自己给自己赋值
		{
			//如果自己给自己赋值，会发生错误
			m_nLength = c.m_nLength;
			m_nWidth = c.m_nWidth;
			//接下来涉及到指针属性的时候，要实现深拷贝的赋值，如果没有实现深拷贝，那么会导致错误
			if (c.m_pName!=NULL)
			{
				m_pName = new char[strlen(c.m_pName) + 1];//这里给被赋值对象申请了独立的空间来保持名字，实现了深拷贝
				strcpy_s(m_pName, strlen(c.m_pName) + 1, c.m_pName);
			}
		}
		return *this;//别忘了这一行
	}
	void show()
	{
		cout << "长：" << m_nLength << "，宽：" << m_nWidth << "，姓名：" << m_pName << endl;
	}
};
void test08()
{
	C c1(8, 3, "c1");
	C c2(6, 4, "c2");
	c1.show();
	c2.show();
	//开始赋值
	c2 = c1;//使用c1对象，对c2进行赋值
	c1.show();
	c2.show();
}

//this指针的作用
class This_Class
{
	int x;
	int y;
public:
	//This_Class(int x = 0, int y = 0) { x = x; y = y; }//属性变量和形参变量名字一样了，就无法赋值了
	This_Class(int x = 0, int y = 0) { this->x = x; this->y = y; }//属性变量和形参变量名字一样，但是可以使用this指针来指定
	void show() { cout << x << "," << y << endl; }
};
void test09()
{
	This_Class this1(5, 8);
	this1.show();//可见，当没有使用this指针的时候，构造函数无法完成赋值，当我们改造后，使用this指针指定为当前对象的属性时，就可以赋值成功。

}
int main()
{
	//test02();
	//test03();
	//test04();
	//test05();
	//test06();
	//test07();
	//test08();
	test09();

	return 0;
}

/*
2.类与对象
	2.1类的定义
	2.2成员的访问控制
	2.3类的数据成员和成员函数
	2.4对象的创建与访问
	2.5类的特殊成员
	2.6类的设计（类的封装）

2.1类的定义
	语法格式：
	1.类的说明部分，一般会放在头文件中
	class 类名
	{
		private:
			私有数据成员和成员函数
		protected:
			保护数据成员和成员函数
		public:
			公有数据成员和成员函数
	};
	2.类的实现部分
	可以在另一个源文件中，实现类中的成员函数

	解释：
		class是定义类的关键字，后面跟上类名
		类名是一个标识符（按照规范应该使用大驼峰命名法：每个单词的首字母大写，其他字母小写）
		这对大括号表示类的作用域，称为类体
		分号表示类定义结束
		关键字private/protected/public称为访问控制修饰符，描述类中成员的可见性
		类中的成员函数，可以在类中直接写出函数定义，这就是在类内实现。也可以只在类中声明函数的原型，但不写方法体，然后去类外实现函数的定义。

2.2成员的访问控制
	在类体中，有数据成员（属性）和成员函数（方法）。他们在程序中的使用收到成员的访问权限的限制，访问权限分为三种：
	private私有访问权限：在private关键字后面声明的属性和方法具有私有访问权限，即只允许本类的成员函数访问，对类外部不可见不可访问。属性一般设为私有，主要目的是保护对象的隐私。
	protected保护访问权限：在protected关键字后面声明的属性和方法具有保护访问权限，保护成员是有限访问的。即能被本类的成员函数访问，也能被派生类访问（讲到继承的时候再说），类外不可见不可访问。
	public公有访问权限：在public关键字后面声明的属性和方法具有公有访问权限，公有的成员对类内、派生类、类外都可以访问。方法一般设为公有，因为要对外提供调用服务。
	如果没有显式声明访问控制权限，那么默认为私有权限。

2.3类的数据成员和成员函数
	类中的数据成员即属性，描述的是对象的特征。必须在类体中定义，它们的定义方式与一般变量相同，但收到访问控制修饰符的限制。
	定义数据成员时的注意事项：
		数据成员初始化与变量初始化形式有所不同，不同使用小括号()初始化，可以使用=和{}来初始化。
		数据成员的类型可以时任意类型，如果是数组类型，必须指定数组的大小。
		多个数据成员之间不能重名，一个类作为一个作用域。
		类定义在前，使用在后。如果在类A中使用了类B（B是A类的属性），如果B还未定义，需要做一个前向声明：
		class B;//前向声明
		class A
		{
			B m_Bobj;
		};

	类的成员函数即方法，描述的是对象的行为，即该类对象能执行什么操作，目的是完成一项功能，向类外提供一种服务。
	定义成员函数时的注意事项：
		类外定义成员函数时需要在函数名前面使用类名+域运算符来指定这是哪个类的成员函数。
		一个类中的多个成员函数可以重载，即函数名相同，但形参个数或类型不同。函数的返回值不能够成重载。
		类的成员函数也可以是内联函数，有两种方法：一种是将成员函数的定义直接写在类体中；另一种是在类外定义成员函数时，使用inline来声明。
		类的成员函数的形参也可以带默认值。

2.4对象的创建与访问
	对象的创建：
		如何使用一个类，首先是创建类的对象，然后操作对象来完成具体的功能。
		在创建对象的时候，需要说明该对象所属的类，创建对象就是这个类的一次实例化过程。
			举例：
			在栈内存创建对象：Rect r1;
			在堆内存空间创建对象（动态创建）：Rect *pr2=new Rect;
	对象的访问：
		操作一个对象是通过访问对象的成员（属性和方法）来实现的。
		如果是普通对象可以使用.运算符去访问如r1.getArea()，如果是对象指针，pr2->getArea()
	类与对象的关系：
		类与对象是抽象和具体的关系，类是创建对象的模板，基于这个模板可以创建很多个对象。每个对象的属性值可以不同，但共同了类中的方法。
		在程序运行时，类是静态的无法改变的，对象是动态的，对象的属性是可以被改变的。一个对象就是某个类的一个实例，创建对象的过程称为类的实例化。
		对象被创建后才真正存在，对象具有一定的生命周期。我们可以通过对象的名字、指针、引用来区分对象。
		一个类实例化出来的多个对象分别拥有自己的属性且相互独立，每个对象都要分配内存空间。而成员函数由所有对象共享的。

2.5类的特殊成员
	类的成员函数中有一些具有特殊功能，称为特殊成员，如：构造函数、析构函数、拷贝构造函数等等
	构造函数：
		在定义变量时可以为变量提供初始值，即初始化。同样在定义对象时也可以为对象的属性提供初始值，即对象初始化。构造函数就是用来完成对象初始化的。
		而且一般会提供多个构造函数，以实现不同的初始化方式。
			构造函数的作用：在创建对现时，利用特定的值构造对象，将对象初始化为一个特定的状态。
			构造函数的特点：
				1）构造函数的函数名与类名相同
				2）不能定义构造函数的类型（不能指定构造函数的返回值类型）
				3）构造函数应该声明为共有函数（不然类外无法调用构造函数完成对象初始化）
				4）构造函数不能被对象调用，在创建对象时，构造函数会被编译器自动调用
				5）每个类都会生成一个默认的构造函数，这个函数的函数体为空，参数为空
			构造函数使用的注意事项：
				1）构造函数可以重载，编译器会根据参数来决定调用哪个构造函数
				2）如果类中没有显式定义构造函数，编译器会自动生成一个无参并且函数体为空的构造函数，一旦显式定义了，编译器就不会生成了
				3）无论以什么方式定义对象，都会调用类的构造函数，如果编译器找不到跟实参匹配的构造函数，就会产生编译错误。
				4）为了能以不同的方式来创建对象，往往需要提供多个构造函数。
			成员初始化列表：
				语法格式：构造函数(参数1，参数2...):属性1(参数1),属性2(参数2)...
				这是一种初始化类中的数据成员的高效的方式。对于普通的数据成员来说，除了在构造函数体中为它们初始化之外，还可以使用这种方式初始化。
				但是，以下几种情况必须要使用初始化列表的方式来初始化：
					1）初始化常量成员
						常量成员在定义后其值不能被修改，因此必须在对象创建时进行初始化。使用初始化列表的方式可以避免赋值操作修改常量。
					2）初始化引用成员
						引用必须在定义时初始化，并且一旦初始化后就不能再引用其他对象。使用初始化表可以避免赋值操作，必须使用初始化表的方式初始化
					3）调用基类的带参构造函数（这个知识点放到继承章节讲）
						当派生类需要调用基类的带参构造函数时，必须使用初始化列表来传递参数给基类的构造函数。

	析构函数:
		析构函数主要作用是处理对象消失前的工作。我们知道，栈内存由编译器管理，栈内存中的变量在离开作用域之后，就会被编译器回收掉。
		但是堆内存需要程序员自己管理自己回收，如果类中的属性有指针，这个类实例化对象的时候，动态申请了一块堆内存使用，这时候就需要在对象消失的时候，
		手动来释放这块对内存，否则会发生内存泄漏。
			析构函数的作用：在删除一个对象前被调用，释放该对象成员的内存空间以及一些其他的清理工作（比如关闭文件、关闭数据库连接、关闭套接字连接等等）
			析构函数的特点：
				1）析构函数的名字是在类名前加~
				2）析构函数没有参数，也不能指定返回值类型
				3）一个类中只能定义一个析构函数，所以无法重载
				4）当一个对象消失时，编译器会自动调用析构函数
				5）如果没有显式定义析构函数，编译器也会生成一个默认析构函数，函数体为空
				6）多个对象构造和析构的时候，构造顺序和析构顺序相反

	拷贝构造函数:
		创建一个对象，可以通过构造函数直接创建出来，也可以通过一个已经存在的对象复制而来，即克隆对象。这就是拷贝构造函数的作用。
		拷贝构造函数的作用：可以实现用一个已经存在的对象来初始化一个新对象
		拷贝构造函数的特点：
			1）格式：类名(const 类名 &对象名):成员的初始化列表{函数体} 如：Rect(const Rect &r){函数体}
			2）拷贝构造函数的形参为该类对象的引用，并且一般建议加const声明为常引用对象
			3）编译器也会提供默认的拷贝构造函数，但是默认的拷贝构造函数只能实现浅拷贝，如果要实现深拷贝，需要我们自己写构造函数实现
		浅拷贝和深拷贝的区别：
			浅拷贝：默认提供的拷贝构造函数是浅拷贝，就是将拷贝构造函数中参数对象的属性值赋给新对象的属性。这种复制，对于含有指针类型属性的类，是有问题的。
			深拷贝：需要自己实现拷贝构造函数，在构造新对象的时候，申请自己独立的空间存储拷贝过来的值，这样对象之间是分开管理内存空间的，互不影响。

		拷贝构造函数的参数声明为常引用对象类型的原因：
			如：A(const A& a)
			当调用拷贝构造函数的时候，如果参数不是引用类型如A(A a)，那么会带来一个副作用：会调用一个拷贝构造函数来实现实参对象对形参对象的赋值，
			而使用引用类型的参数时，就没有这次拷贝构造函数的调用过程，因为引用就是那个实参对象的别名，就是它自己。所以我们使用引用类型就可以避免这次拷贝，就可以提升程序效率
			再说const，由于使用了引用类型来传参，就会导致一个风险，是可能会在函数中中修改这个实参对象的属性。那么加上const之后，就会禁止修改这个实参的属性，避免了这种风险。

	赋值函数：
		作用：将一个已有对象赋值给另一个已有对象（这两个对象是同类）
		赋值函数使用赋值运算符来调用的，即=，对于对象来说，可以直接使用=来进行赋值，这时候是调用了编译器自动提供的默认赋值函数，这个赋值只是把对象直接的属性值进行赋值。
		对于，有指针类型属性的对象来说，仍然存在所谓深拷贝浅拷贝的问题，参考拷贝构造函数。
		在类中自定义赋值函数，此时使用=赋值的时候，就会调用我们自定义的函数，而不是使用系统提供的默认赋值函数。
		在类中定义赋值函数的格式如下：
			类名& operator=(const 类名& 对象名){函数体; return *this}//this是这个函数隐藏的一个参数，是一个指针，并且是一个指针常量，始终指向当前调用此函数的对象
			举例：Rect& operator=(const Rect& r){函数体; return *this}
			返回值是当前类对象的引用： return *this;代表返回当前对象，如果不使用引用，由于在函数作用域内拿不到this指针指向的当前对象，如果返回的是一个
			非引用类型的对象，此时编译器会再构造一个新对象来返回，此时就会调用拷贝构造函数。如果返回的是引用，则可以直接通过this指针拿到那个对象返回，就不需要调用拷贝构造函数。
			返回值是引用类型的另一个原因是：如果返回值不是引用类型，那么会调用拷贝构造函数来进行拷贝。而默认的拷贝构造函数是浅拷贝，这样的话就破坏了赋值函数的深拷贝。

		this指针：
			类中有两种类型的成员函数：普通成员函数和静态成员函数，前者比后者多了一个隐藏的参数this，它是普通成员函数的第一个参数，该参数类型为指向当前对象
			的const指针，当前对象即调用此函数的对象。当一个对象调用普通成员函数时，这个对象的地址会传递给this这个参数。
			this指针的作用：
				可以用来专门指定当前对象

				2025.3.26讲：
2.6类的设计（类的封装）
	以上所做的所有工作都是在设计类，也叫封装。封装的目的是隐藏对象的属性和是实现的细节，仅仅对外提供接口即可。
	一般来说我们设计一个类的时候，按照如下几个步骤展开：
		1）类的分析过程，需求的分析过程，根据需求和功能抽象不同的事物，分析每个事物的属性和方法，然后再确定访问控制权限。这里可以先写方法原型声明，不需要实现
		2）除了一般成员函数之外，还需要实现一些特殊的成员函数。比如构造函数、析构函数、拷贝构造函数、赋值函数等等
		3）还有考虑多个类之间的相互关系和结构，这就涉及到设计模式的知识。
*/